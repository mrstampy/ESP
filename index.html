<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Esp : ESP - An EEG Signal Processing Library" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Esp</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/mrstampy/ESP">View on GitHub</a>

          <h1 id="project_title">Esp</h1>
          <h2 id="project_tagline">ESP - An EEG Signal Processing Library</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/mrstampy/ESP/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/mrstampy/ESP/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="esp---an-eeg-signal-processing-library" class="anchor" href="#esp---an-eeg-signal-processing-library"><span class="octicon octicon-link"></span></a>ESP - An EEG Signal Processing Library</h1>

<p>This library provides the ability to connect to the <a href="http://www.neurosky.com">NeuroSky</a> MindWave ThinkGear connector and the OCZ Nia. As of version 1.3 the core functionality has been abstracted.  The ThinkGear classes are now a separate library as are the Nia classes. It is designed to be fast and efficient, using high performance Java libraries:</p>

<ul>
<li><a href="https://github.com/LMAX-Exchange/disruptor">Disruptor</a></li>
<li><a href="http://javolution.org/">Javolution</a></li>
<li><a href="http://mina.apache.org/">Apache MINA</a></li>
<li><a href="https://github.com/Netflix/RxJava/">RxJava</a></li>
</ul><h2>
<a name="release-21-25-05-14" class="anchor" href="#release-21-25-05-14"><span class="octicon octicon-link"></span></a>Release 2.1, 25-05-14</h2>

<ul>
<li>Added Lab and Connection abstractions (explained below)</li>
<li>Implemented multi channel support</li>
</ul><h2>
<a name="release-20-29-04-14" class="anchor" href="#release-20-29-04-14"><span class="octicon octicon-link"></span></a>Release 2.0, 29-04-14</h2>

<ul>
<li>Added <a href="https://github.com/Netflix/RxJava/">RxJava</a> to the project</li>
<li>Added ability to tune sample buffer size to more closely represent 1 second's worth of data</li>
<li>Utilizing Disruptor in raw sample buffer</li>
<li>Sample rate and sample size now mutable</li>
<li>Sample rates above 1kHz allowed</li>
<li>Reasonable results sampling into the 50kHz range
# ESP - An EEG Signal Processing Library</li>
</ul><h2>
<a name="design-goals" class="anchor" href="#design-goals"><span class="octicon octicon-link"></span></a>Design Goals</h2>

<p>ESP is designed to provide Java programs access to EEG device signals and provide the ability to process the signals for the purposes of the program. The ESP library itself is not an implementation, however there are several implementations for specific EEG devices:</p>

<ul>
<li><a href="http://mrstampy.github.io/ESP-Nia/">ESP-Nia</a></li>
<li><a href="http://mrstampy.github.io/ESP-ThinkGear/">ESP-ThinkGear</a></li>
<li><a href="http://mrstampy.github.io/ESP-OpenBCI/">ESP-OpenBCI (experimental)</a></li>
<li><a href="http://mrstampy.github.io/ESPLab/">ESPLab (JavaFX 8.0 GUI for the ESP Lab interface)</a></li>
</ul><p>ESP provides a common structure for device specific implementations.  This allows programs using the ESP libraries to cater for multiple devices from a single codebase.</p>

<h2>
<a name="primary-design-specifics" class="anchor" href="#primary-design-specifics"><span class="octicon octicon-link"></span></a>Primary Design Specifics</h2>

<h3>
<a name="the-multiconnectsocket-interface" class="anchor" href="#the-multiconnectsocket-interface"><span class="octicon octicon-link"></span></a><a href="https://github.com/mrstampy/ESP/blob/master/ESP/src/com/github/mrstampy/esp/multiconnectionsocket/MultiConnectionSocket.java">The MultiConnectSocket Interface</a>
</h3>

<p>This interface defines the methods that must be implemented for a class which provides access to EEG hardware. An <a href="https://github.com/mrstampy/ESP/blob/master/ESP/src/com/github/mrstampy/esp/multiconnectionsocket/AbstractMultiConnectionSocket.java">abstract superclass</a> exists for ease of implementation.</p>

<h3>
<a name="the-rawespconnection-interface" class="anchor" href="#the-rawespconnection-interface"><span class="octicon octicon-link"></span></a><a href="https://github.com/mrstampy/ESP/blob/master/ESP/src/com/github/mrstampy/esp/dsp/lab/RawEspConnection.java">The RawEspConnection Interface</a>
</h3>

<p>RawEspConnection extends the MultiConnectSocket interface. Implementations are intended to encapsulate and control a MultiConnectSocket instance through the implementation of the common methods, as well as provide the current seconds' worth of samples on demand for direct use or further processing.  Signal processing methods exist to provide ease of processing the signal.  An <a href="https://github.com/mrstampy/ESP/blob/master/ESP/src/com/github/mrstampy/esp/dsp/lab/AbstractRawEspConnection.java">abstract superclass</a> exists for ease of implementation.</p>

<h3>
<a name="the-lab-interface" class="anchor" href="#the-lab-interface"><span class="octicon octicon-link"></span></a><a href="https://github.com/mrstampy/ESP/blob/master/ESP/src/com/github/mrstampy/esp/dsp/lab/Lab.java">The Lab Interface</a>
</h3>

<p>While the ESP library provides DSP processing classes, how the signal is processed is left to programs using the library.  Lab implementations provide the ability to obtain the current seconds' worth of samples from the encapsulated RawEspConnection, process the signal and notify the program when a sample is ready for use.</p>

<p>A <a href="https://github.com/mrstampy/ESP/blob/master/ESP/src/com/github/mrstampy/esp/dsp/lab/DefaultLab.java">default implementation</a>
exists and an <a href="https://github.com/mrstampy/ESP/blob/master/ESP/src/com/github/mrstampy/esp/dsp/lab/AbstractLab.java">abstract superclass</a> provides ease
of custom lab implementation. </p>

<h2>
<a name="usage" class="anchor" href="#usage"><span class="octicon octicon-link"></span></a>Usage</h2>

<h3>
<a name="direct-multiconnectsocket-usage" class="anchor" href="#direct-multiconnectsocket-usage"><span class="octicon octicon-link"></span></a>Direct MultiConnectSocket Usage</h3>

<p>This is the lowest level use case.  Programs using ESP library implementations in this manner will receive device-specific signals as they occur.  Each implementation of the ESP library's MultiConnectSocket has a device-specific listener mechanism to obtain the signal.  Pseudo code for usage appears as so:</p>

<pre><code>    SomeMultiConnectSocketImpl socket = new SomeMultiConnectSocketImpl();

    // optional, common to all MultiConnectSocket implementations:
    // add a listener to receive connect/disconnect events
    socket.addConnectionEventListener(new ConnectionEventListener() {
        public void connectionEventPerformed(ConnectionEvent e) {
            doSomethingWith(e);
        }
    });

    socket.addDeviceSpecificListener(new DeviceSpecificListener() {
        public void someDataForYou(DeviceSpecificEvent e) {
            doSomethingWith(e);
        }
    });

    socket.start();
</code></pre>

<h3>
<a name="direct-multiconnectsocket-usage---remote-connection" class="anchor" href="#direct-multiconnectsocket-usage---remote-connection"><span class="octicon octicon-link"></span></a>Direct MultiConnectSocket Usage - Remote Connection</h3>

<p>This functionality is from where the MultiConnectSocket derives its name.  Device specific implementations provide the ability to open a socket on a configurable port.  Such sockets facilitate a subscribe and publish of device signals. This allows separate processes and machines to <a href="https://github.com/mrstampy/ESP/blob/master/ESP/src/com/github/mrstampy/esp/multiconnectionsocket/AbstractSocketConnector.java">receive the device signals</a> for their own purposes - signal recording, secondary processing, display etc.</p>

<pre><code>    // on the host machine or process:
    // port is set via the system property 'socket.broadcaster.port', default '12345'
    SomeMultiConnectSocketImpl socket = new SomeMultiConnectSocketImpl(true);

    // on the remote process/machine:
    // port is set via the system property 'socket.broadcaster.port', default '12345'
    AbstractSocketConnectorImpl connector = new AbstractSocketConnectorImpl("host machine name or IP address");

    connector.addDeviceSpecificListener(new DeviceSpecificListener() {
        public void someDataForYou(DeviceSpecificEvent e) {
            doSomethingWith(e);
        }
    });

    connector.connect();
    connector.subscribe(....);

    // and back on the host machine or process:
    socket.start();
</code></pre>

<h3>
<a name="rawespconnection-usage" class="anchor" href="#rawespconnection-usage"><span class="octicon octicon-link"></span></a>RawEspConnection Usage</h3>

<p>RawEspConnection implementations aggregate the current second's worth of data, insulating the program from device specific listeners.  The samples are intended to be queried periodically in a separate scheduled task or thread.  The period of querying is left to the program and is independent of sample rate.</p>

<pre><code>    DeviceSpecificConnection connection = new DeviceSpecificConnection();

    // optional, common to all RawEspConnection implementations:
    // add a listener to receive connect/disconnect events
    connection.addConnectionEventListener(new ConnectionEventListener() {
        public void connectionEventPerformed(ConnectionEvent e) {
            doSomethingWith(e);
        }
    });

    connection.start();

    // in a separate scheduled periodic task..
    int channel = 1; // channel of interest 
    dealWithCurrentSecondOfSamples(connection.getCurrentFor(channel));
</code></pre>

<h3>
<a name="lab-usage" class="anchor" href="#lab-usage"><span class="octicon octicon-link"></span></a>Lab Usage</h3>

<p>Lab implementations provide the ability to process the current seconds' worth of data from the RawEspConnection and notify any interested parties of its completion. Triggering of signal processing is intended to be executed periodically in a separate scheduled task or thread.  The period of triggering is left to the program and is independent of sample rate.</p>

<pre><code>    DeviceSpecificConnection connection = new DeviceSpecificConnection();

    // optional, common to all RawEspConnection implementations:
    // add a listener to receive connect/disconnect events
    connection.addConnectionEventListener(new ConnectionEventListener() {
        public void connectionEventPerformed(ConnectionEvent e) {
            doSomethingWith(e);
        }
    });

    Lab lab = connection.getDefaultLab();

    int numBands = 40; // first 40 bands
    lab.setNumBands(numBands); // must be set

    int channel = 1; // channel of interest for multichannels
    lab.setChannel(channel); // required if &gt; 1 channel

    lab.addSignalProcessedListener(new SignalProcessedListener() {
        public void signalProcessed(double[] processed) {
            doSomethingWith(processed);
        }
    });

    // other lab values set as appropriate for processing the signal

    connection.start();

    // in a separate scheduled periodic task..
    lab.triggerProcessing();
</code></pre>

<h2>
<a name="maven-dependencies" class="anchor" href="#maven-dependencies"><span class="octicon octicon-link"></span></a>Maven Dependencies</h2>

<pre><code>   &lt;dependency&gt;
       &lt;groupId&gt;com.github.mrstampy&lt;/groupId&gt;
       &lt;!-- for the ThinkGear implementation --&gt;
       &lt;artifactId&gt;esp-thinkgear&lt;/artifactId&gt;
       &lt;version&gt;2.1&lt;/version&gt;
   &lt;/dependency&gt;

   &lt;dependency&gt;
       &lt;groupId&gt;com.github.mrstampy&lt;/groupId&gt;
       &lt;!-- for the Nia implementation --&gt;
       &lt;artifactId&gt;esp-nia&lt;/artifactId&gt;
       &lt;version&gt;2.1&lt;/version&gt;
   &lt;/dependency&gt;

   &lt;dependency&gt;
       &lt;groupId&gt;com.github.mrstampy&lt;/groupId&gt;
       &lt;!-- for the base classes, if not using the above implementations --&gt;
       &lt;artifactId&gt;esp&lt;/artifactId&gt;
       &lt;version&gt;2.1&lt;/version&gt;
   &lt;/dependency&gt;
</code></pre>

<p>Usage of the library is straight-forward. One only needs to instantiate the AbstractMultiConnectionSocket implementation, add a listener, start the socket and deal with the events as they occur.</p>

<h2>
<a name="multiple-connections" class="anchor" href="#multiple-connections"><span class="octicon octicon-link"></span></a>Multiple Connections</h2>

<p>As implied by the name of the class, the AbstractMultiConnectionSocket is capable of not only processing ThinkGear messages for a single application but also of broadcasting the messages to separate applications, even on separate machines and devices! This functionality is disabled by default. To enable it either set the System property 'broadcast.messages' to true or instantiate the MultiConnectionThinkGearSocket using one of its other constructors:</p>

<pre><code>MultiConnectionThinkGearSocket socket = new MultiConnectionThinkGearSocket("ThinkGear socket hostname", true);
...
socket.start();

...and then in another application:
</code></pre>

<p>ThinkGearSocketConnector connector = new ThinkGearSocketConnector("Hostname running MultiConnectionThinkGearSocket");</p>

<pre><code>connector.addThinkGearEventListener(new ThinkGearEventListenerAdapter() {
    // overriding methods as appropriate
});

connector.connect();

//after successful connection...
connector.subscribe(EventType...);
</code></pre>

<h2>
<a name="raw-signal-processing-as-of-version-13" class="anchor" href="#raw-signal-processing-as-of-version-13"><span class="octicon octicon-link"></span></a>Raw Signal Processing (as of version 1.3)</h2>

<p>In the development of the <a href="http://mrstampy.github.com/ESP-Nia/">ESP-Nia</a> implementation the base classes for raw signal processing were developed.  Multi connection socket implementations contain a raw data buffer which contains the current second's worth of data (for the OCZ Nia this translates to 3910 data points, for the ThinkGear devices this translates to 512 data points).</p>

<p>Additional classes have been added to assist with raw signal processing. The examples shown will work with the NeuroSky raw output however these classes can be used for any DSP work.</p>

<p>Additional functionality is described in the JavaDocs. This work is released under the GPL 3.0 license. No warranty of any kind is offered.</p>

<p><a href="http://mrstampy.github.io/ESP/">ESP</a> Copyright (C) 2013 - 2014 Burton Alexander. </p>

<p>eSense, ThinkGear, MDT, NeuroBoy and NeuroSky are trademarks of <a href="http://www.neurosky.com">NeuroSky Inc</a>.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Esp maintained by <a href="https://github.com/mrstampy">mrstampy</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
